<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-25 Fri 19:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Philosophical Foundations Part 2E: Razors, Heuristics, Proofs, and Proof Strategies</title>
<meta name="author" content="ZeroContradictions" />
<meta name="description" content="[Make this the same as home page keywords description]" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../blog-posts.css" />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../epistemology.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Philosophical Foundations Part 2E: Razors, Heuristics, Proofs, and Proof Strategies</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#philosophical-razors">1. Philosophical Razors (And Alternative Names For Describing Them)</a></li>
<li><a href="#orgf538307">2. Heuristics</a>
<ul>
<li><a href="#prioritization-of-thinking">2.1. Prioritization Of Thinking In Philosophy</a></li>
<li><a href="#mirror-test-sequels">2.2. The Sequels To The Mirror Test</a></li>
</ul>
</li>
<li><a href="#proofs">3. Proofs</a>
<ul>
<li><a href="#proofs-intro">3.1. Introduction to Proofs</a></li>
<li><a href="#types-of-proofs">3.2. Types Of Proofs</a></li>
<li><a href="#tips-for-proving-certain-things">3.3. Tips For Proving Certain Things</a></li>
</ul>
</li>
<li><a href="#universal-quantifier-proof-strategies">4. Universal Quantifier Proof Strategies</a>
<ul>
<li><a href="#proving-universals">4.1. To prove a universal statement (∀x.P(x)):</a></li>
<li><a href="#proving-universals-in-domain">4.2. There are some variations of this. This strategy handles a universal quantifier over a restricted domain:</a></li>
<li><a href="#proving-universal-implications">4.3. This strategy combines the universal quantifier and implication strategies: this is a very common kind of statement.</a></li>
</ul>
</li>
<li><a href="#existential-quantifier-proof-strategies">5. Existential Quantifier Proof Strategies</a>
<ul>
<li><a href="#proving-existentials">5.1. To prove a statement of the form (∃x.P (x)):</a></li>
<li><a href="#proving-existentials-in-domain">5.2. To prove a statement of the form (∃x ∈ A.P (x)):</a></li>
</ul>
</li>
</ul>
</div>
</div>
<hr />
<p>
Note: I haven&rsquo;t finished writing this file yet.
</p>

<div id="outline-container-philosophical-razors" class="outline-2">
<h2 id="philosophical-razors"><span class="section-number-2">1.</span> Philosophical Razors (And Alternative Names For Describing Them)</h2>
<div class="outline-text-2" id="text-philosophical-razors">
<p>
In philosophy, a razor is a principle or rule of thumb that allows one to eliminate (&ldquo;shave off&rdquo;) unlikely explanations for a phenomenon, or avoid unnecessary actions.[1][2][3] Razors include:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Razor Name</th>
<th scope="col" class="org-left">Principle</th>
<th scope="col" class="org-left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Occam&rsquo;s Razor</td>
<td class="org-left">Simplicity</td>
<td class="org-left">Simpler explanations are more likely to be correct; avoid unnecessary or improbable assumptions.</td>
</tr>

<tr>
<td class="org-left">Hanlon&rsquo;s Razor</td>
<td class="org-left">Attribute Stupidity over malice</td>
<td class="org-left">Never attribute to malice that which can be adequately explained by stupidity.</td>
</tr>

<tr>
<td class="org-left">Hitchens&rsquo; Razor</td>
<td class="org-left">Dismiss assertions without evidence</td>
<td class="org-left">What can be asserted without evidence can be dismissed without evidence.</td>
</tr>

<tr>
<td class="org-left">Hume&rsquo;s Guillotine</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">What ought to be cannot be deduced from what is.</td>
</tr>

<tr>
<td class="org-left">Sagan Standard</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">If something cannot be settled by experiment or observation, then it is not worthy of debate.</td>
</tr>

<tr>
<td class="org-left">Popper&rsquo;s Falsifiability Principle</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">For a theory to be considered scientific, it must be falsifiable.</td>
</tr>

<tr>
<td class="org-left">Grice&rsquo;s Razor</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">As a principle of parsimony, conversational implications are to be preferred over semantic context for linguistic explanations.</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Occam&rsquo;s Razor: Simpler explanations are more likely to be correct; avoid unnecessary or improbable assumptions.</li>
<li>Hanlon&rsquo;s Razor: Never attribute to malice that which can be adequately explained by stupidity.</li>
<li>Hitchens&rsquo; Razor: What can be asserted without evidence can be dismissed without evidence.</li>
<li>Hume&rsquo;s Guillotine: What ought to be cannot be deduced from what is. &ldquo;If the cause, assigned for any effect, be not sufficient to produce it, we must either reject that cause, or add to it such qualities as will give it a just proportion to the effect.&rdquo;</li>
<li>Alder&rsquo;s Razor: If something cannot be settled by experiment or observation, then it is not worthy of debate.</li>
<li>Sagan Standard: Extraordinary claims require extraordinary evidence.</li>
<li>Popper&rsquo;s Falsifiability Principle: For a theory to be considered scientific, it must be falsifiable.</li>
<li>Grice&rsquo;s Razor: As a principle of parsimony, conversational implications are to be preferred over semantic context for linguistic explanations.</li>
</ul>
<p>
The primary goals of the philosophical razors are to figure out what can be quickly and summarily dismissed. The rationale behind this is to save time by not wasting it on things that are probably false and/or will lead towards dead-ends.
</p>

<p>
This rationale can be seen as a subcategory of rational ignorance. Although there might be knowledge to be gained by fully understanding and evaluating something that can be dismissed by a philosophical razor in greater depth, the costs of understanding the claims and arguments in question would exceed any benefits gained by understanding and evaluating those arguments. Most of the knowledge that would be gained from exploring the razor-dismissed arguments in greater depth would likely consist of understanding why the arguments are wrong, but this in time in greater detail, in comparison to why they can be summarily dismissed by the philosophical razors.
</p>
</div>
</div>

<div id="outline-container-orgf538307" class="outline-2">
<h2 id="orgf538307"><span class="section-number-2">2.</span> Heuristics</h2>
<div class="outline-text-2" id="text-2">
<p>
The book <i>How to Solve It</i> by George Polya contains a dictionary-style set of heuristics, many of which have to do with generating a more accessible problem. For example:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Heuristic</td>
<td class="org-left">Informal Description</td>
<td class="org-left">Formal analogue</td>
</tr>

<tr>
<td class="org-left">Analogy</td>
<td class="org-left">Can you find a problem analogous to your problem and solve that?</td>
<td class="org-left">Map</td>
</tr>

<tr>
<td class="org-left">Auxiliary Elements</td>
<td class="org-left">Can you add some new element to your problem to get closer to a solution?</td>
<td class="org-left">Extension</td>
</tr>

<tr>
<td class="org-left">Generalization</td>
<td class="org-left">Can you find a problem more general than your problem?</td>
<td class="org-left">Generalization</td>
</tr>

<tr>
<td class="org-left">Induction</td>
<td class="org-left">Can you solve your problem by deriving a generalization from some examples?</td>
<td class="org-left">Induction</td>
</tr>

<tr>
<td class="org-left">Variation of the Problem</td>
<td class="org-left">Can you change your problem to create a new problem(s) whose solution(s) will help you solve your original?</td>
<td class="org-left">Search</td>
</tr>

<tr>
<td class="org-left">Auxiliary Problem</td>
<td class="org-left">Can you find a subproblem or side problem whose solution will help you solve your problem?</td>
<td class="org-left">Subgoal</td>
</tr>

<tr>
<td class="org-left">Use a related solved problem</td>
<td class="org-left">Can you find a problem related to yours that has already been solved and use that to solve your problem?</td>
<td class="org-left">Pattern Recognition/Matching/Reduction</td>
</tr>

<tr>
<td class="org-left">Specialization</td>
<td class="org-left">Can you find a problem more specialized?</td>
<td class="org-left">Specialization</td>
</tr>

<tr>
<td class="org-left">Decomposing and Recombining</td>
<td class="org-left">Can you decompose the problem and &ldquo;recombine its elements in some new manner&rdquo;?</td>
<td class="org-left">Divide and conquer</td>
</tr>

<tr>
<td class="org-left">Working backward</td>
<td class="org-left">Can you start with the goal and work backwards to something you already know?</td>
<td class="org-left">Backward chaining</td>
</tr>

<tr>
<td class="org-left">Draw a Figure</td>
<td class="org-left">Can you draw a picture of the problem?</td>
<td class="org-left">Diagrammatic Reasoning</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-prioritization-of-thinking" class="outline-3">
<h3 id="prioritization-of-thinking"><span class="section-number-3">2.1.</span> Prioritization Of Thinking In Philosophy</h3>
<div class="outline-text-3" id="text-prioritization-of-thinking">
<ol class="org-ol">
<li>Putting &ldquo;what is&rdquo; before &ldquo;what ought&rdquo;.</li>
<li>Putting &ldquo;how&rdquo; before &ldquo;why&rdquo;.</li>
<li>i</li>
</ol>
</div>
</div>

<div id="outline-container-mirror-test-sequels" class="outline-3">
<h3 id="mirror-test-sequels"><span class="section-number-3">2.2.</span> The Sequels To The Mirror Test</h3>
<div class="outline-text-3" id="text-mirror-test-sequels">
<p>
Most homo sapiens can pass the mirror test, but a majority of them cannot pass the following sequels:
</p>
<ul class="org-ul">
<li>Recognizing that supernatural deity(ies) don&rsquo;t exist (their existence is false).</li>
<li>Recognizing the non-existence of free will.</li>
<li>Recognizing the non-existence of an ontology of &ldquo;objective morality&rdquo;.</li>
<li>Recognizing Georgism (the &ldquo;Economic Mirror Test&rdquo;).</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-proofs" class="outline-2">
<h2 id="proofs"><span class="section-number-2">3.</span> Proofs</h2>
<div class="outline-text-2" id="text-proofs">
</div>
<div id="outline-container-proofs-intro" class="outline-3">
<h3 id="proofs-intro"><span class="section-number-3">3.1.</span> Introduction to Proofs</h3>
<div class="outline-text-3" id="text-proofs-intro">
<ul class="org-ul">
<li>Axioms are statements assumed to be true. There are two types of axioms: Logical Axioms and Domain Axioms.</li>
<li>Theorems are statements that can be proven to be true.</li>
<li>Answering whether statements are provable or not is a set theory topic.
<ul class="org-ul">
<li>If a statement is provable (meaning that it is theorem), we write a proof to prove it.</li>
<li>If a statement is improvable, it goes to the backburner.</li>
</ul></li>
<li>A proof consists of a series of steps, each that follow logically from assumptions or previously proven statements, whose final step results in the statement of the theorem being proven.</li>
<li>Theorems should be rewritten using precise mathematical language before they are proven. All the assumptions in the theorem&rsquo;s statement and everything that is know should be written down.</li>
<li>If a direct proof is not being done, it is good practice to state what type of proof is being done.</li>
<li>Much like programming, it is extremely helpful to have someone else look over your proof. They will often be able to critique, spot holes, or make suggestions to improve your proof.</li>
</ul>
</div>
</div>

<div id="outline-container-types-of-proofs" class="outline-3">
<h3 id="types-of-proofs"><span class="section-number-3">3.2.</span> Types Of Proofs</h3>
<div class="outline-text-3" id="text-types-of-proofs">
<ul class="org-ul">
<li>Direct Proofs prove the truth / falsehood of a statement through a set of axioms that prove a conclusion c as a direct result of the assumption, like a conditional statement.
<ul class="org-ul">
<li>In a direct proof of a conditional statement, the hypothesis p is assumed to be true and the conclusion c is proven as a direct result of the assumption.</li>
</ul></li>
<li>Proofs by Contrapositive prove conditional theorems of the form p → c by showing that the contrapositive ¬c → ¬p is true. If the hypothesis is proven false, the conditional is true.
<ul class="org-ul">
<li>Proofs by Contrapositive start by assuming that the conclusion of a conditional theorem is false, then try to prove the hypothesis false.</li>
<li>Sometimes it is more difficult to assume that the entire conclusion is false and it is okay to assume that only part of the conclusion is false to generate a sufficient contradiction.
<ul class="org-ul">
<li>This is the case with proving DeMorgan&rsquo;s Laws. If we assume the entire conclusion is false, then we can&rsquo;t break it down any further without the statement that we are trying to prove.
<ul class="org-ul">
<li>However, it is sufficient to only assume that part of the conclusion is false. As long as this generates a contradiction, this is all you need.</li>
</ul></li>
</ul></li>
</ul></li>
<li>A Proof by Contrapositive is a special case of a proof by contradiction. Proofs by contradiction are more general because they aren&rsquo;t limited to conditional theorems.</li>
<li>Proofs by Contradiction (AKA Indirect Proofs) start by assuming that the theorem is false and then show that some logical inconsistency arises as a result of this assumption.
<ul class="org-ul">
<li>If the theorem being proven has the form p → q, then the beginning assumption is p ∧ ¬q.</li>
<li>Unlike direct proofs and proofs by contrapositive, a proof by contradiction can be used to prove theorems that are not conditional statements.</li>
<li>If t is the statement of the theorem, the proof by contradiction begins with the assumption ¬t and leads to a conclusion r ∧ ¬r, for some proposition r.</li>
</ul></li>
<li>Proofs by Cases prove theorems by separating the domain for the variables into different classes and giving a different proof for every class.
<ul class="org-ul">
<li>Every value in the domain must be included in at least one class.</li>
<li>Proofs by Cases are especially good for biconditional statements.</li>
</ul></li>
<li>Proofs by Induction prove theorems by using a base case, induction hypothesis, and induction step.</li>
<li>Counterexamples are assignments of values to variables that prove that a universal statement is false.
<ul class="org-ul">
<li>It is dangerous to generalize from a set of examples because there can always be a counterexample that was not tried.
<ul class="org-ul">
<li>Therefore, proofs of universal statements are generally more reliable than proofs of exhaustion, except for when the domain is really small.</li>
</ul></li>
</ul></li>
<li>Proofs of Exhaustion prove statements by checking every element of the domain. They are typically used for only small domains.</li>
<li>Proofs by Exhaustion are simply akin to Proofs by Cases with 1000s of individual cases.</li>
</ul>
</div>
</div>

<div id="outline-container-tips-for-proving-certain-things" class="outline-3">
<h3 id="tips-for-proving-certain-things"><span class="section-number-3">3.3.</span> Tips For Proving Certain Things</h3>
<div class="outline-text-3" id="text-tips-for-proving-certain-things">
<p>
One common way to show that two things are equal to each is to show that one element one greater than or equal the other element, and that it is also less than or equal to the other element. Then it must be the case that the first element is equal to the other element.
</p>

<p>
To show that there is only one unique something in a specific case, it is common to assume that there are two different somethings in that case, and then show that they are equal to each other. Then it must be the case that there is only one unique something since they are both are equal to each other.
</p>
</div>
</div>
</div>

<div id="outline-container-universal-quantifier-proof-strategies" class="outline-2">
<h2 id="universal-quantifier-proof-strategies"><span class="section-number-2">4.</span> Universal Quantifier Proof Strategies</h2>
<div class="outline-text-2" id="text-universal-quantifier-proof-strategies">
</div>
<div id="outline-container-proving-universals" class="outline-3">
<h3 id="proving-universals"><span class="section-number-3">4.1.</span> To prove a universal statement (∀x.P(x)):</h3>
<div class="outline-text-3" id="text-proving-universals">
<p>
Goal: (∀x.P(x))
</p>
<ul class="org-ul">
<li>Let k be an arbitary object.</li>
<li>Goal: P(k)</li>
</ul>
</div>
</div>

<div id="outline-container-proving-universals-in-domain" class="outline-3">
<h3 id="proving-universals-in-domain"><span class="section-number-3">4.2.</span> There are some variations of this. This strategy handles a universal quantifier over a restricted domain:</h3>
<div class="outline-text-3" id="text-proving-universals-in-domain">
<p>
Goal: (∀x ∈ A.P (x))
</p>
<ul class="org-ul">
<li>Let k be an arbitary object.</li>
<li>Assume: k ∈ A</li>
<li>Goal: P(k)</li>
</ul>
</div>
</div>

<div id="outline-container-proving-universal-implications" class="outline-3">
<h3 id="proving-universal-implications"><span class="section-number-3">4.3.</span> This strategy combines the universal quantifier and implication strategies: this is a very common kind of statement.</h3>
<div class="outline-text-3" id="text-proving-universal-implications">
<p>
Goal: (∀x ∈ A.P (x) → Q(x))
</p>
<ul class="org-ul">
<li>Let k be an arbitary object.</li>
<li>Assume: P(k)</li>
<li>Goal: Q(k)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-existential-quantifier-proof-strategies" class="outline-2">
<h2 id="existential-quantifier-proof-strategies"><span class="section-number-2">5.</span> Existential Quantifier Proof Strategies</h2>
<div class="outline-text-2" id="text-existential-quantifier-proof-strategies">
</div>
<div id="outline-container-proving-existentials" class="outline-3">
<h3 id="proving-existentials"><span class="section-number-3">5.1.</span> To prove a statement of the form (∃x.P (x)):</h3>
<div class="outline-text-3" id="text-proving-existentials">
<p>
Goal: (∃x.P(x))
</p>
<ul class="org-ul">
<li>Find a suitable c. This will usually take some thought.</li>
<li>Goal: P(c)</li>
</ul>
</div>
</div>

<div id="outline-container-proving-existentials-in-domain" class="outline-3">
<h3 id="proving-existentials-in-domain"><span class="section-number-3">5.2.</span> To prove a statement of the form (∃x ∈ A.P (x)):</h3>
<div class="outline-text-3" id="text-proving-existentials-in-domain">
<p>
Note: This is the version for statements with a restricted quantifier.
</p>

<p>
Goal: (∃x.P(x))
</p>
<ul class="org-ul">
<li>Find a suitable c. This will usually take some thought.</li>
<li>Goal 1: c ∈ A (this often doesn&rsquo;t require much work)</li>
<li>Goal 2: P(c)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: ZeroContradictions</p>
<p class="date">Created: 2022-11-25 Fri 19:04</p>
</div>
</body>
</html>
